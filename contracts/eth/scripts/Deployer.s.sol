// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {stdJson} from "forge-std/StdJson.sol";
import {Script, console} from "forge-std/Script.sol";
import {Proxy, ProxyAdmin} from "../src/Proxy.sol";
import {StandardBridge} from "../src/StandardBridge.sol";
import {WWaves} from "../src/WWaves.sol";
import {TERC20} from "../utils/TERC20.sol";
import {UnitsMintableERC20} from "../src/UnitsMintableERC20.sol";

contract Deployer is Script {
    StandardBridge public standardBridge;
    Proxy public bridgeProxy;
    ProxyAdmin public bridgeProxyAdmin;
    TERC20 public terc20;
    UnitsMintableERC20 public wwaves;

    /// @notice The namespace for the deployment. Can be set with the env var DEPLOYMENT_CONTEXT.
    string internal deploymentContext;
    /// @notice Path to the deploy artifact generated by foundry
    string internal deployPath;
    /// @notice Path to the directory containing the hh deploy style artifacts
    string internal deploymentsDir;
    /// @notice The name of the deploy script that sends the transactions.
    ///         Can be modified with the env var DEPLOY_SCRIPT
    string internal deployScript;
    /// @notice The path to the temp deployments file
    string internal tempDeploymentsPath;
    /// @notice Error for when attempting to fetch a deployment and it does not exist

    function setUp() public {
        string memory root = vm.projectRoot();
        deployScript = vm.envOr("DEPLOY_SCRIPT", string("default"));

        string memory sig = vm.envOr("SIG", string("run"));
        string memory deployFile = vm.envOr("DEPLOY_FILE", string.concat(sig, "-latest.json"));
        uint256 chainId = vm.envOr("CHAIN_ID", block.chainid);
        deployPath = string.concat(root, "/broadcast/", deployScript, ".s.sol/", vm.toString(chainId), "/", deployFile);

        deploymentsDir = string.concat(root, "/target/deployments/", vm.toString(chainId));
        try vm.createDir(deploymentsDir, true) {} catch (bytes memory) {}

        string memory chainIdPath = string.concat(deploymentsDir, "/.chainId");
        try vm.readFile(chainIdPath) returns (string memory localChainId) {
            if (vm.envOr("STRICT_DEPLOYMENT", true)) {
                require(
                    vm.parseUint(localChainId) == chainId,
                    string.concat("Misconfigured networks: ", localChainId, " != ", vm.toString(chainId))
                );
            }
        } catch {
            vm.writeFile(chainIdPath, vm.toString(chainId));
        }
        console.log("Connected to network with chainid %s", chainId);

        tempDeploymentsPath = string.concat(deploymentsDir, "/.deploy");
        try vm.readFile(tempDeploymentsPath) returns (string memory) {}
        catch {
            vm.writeJson("{}", tempDeploymentsPath);
        }
        console.log("Storing temp deployment data in %s", tempDeploymentsPath);
    }

    function run() public {
        vm.startBroadcast();

        standardBridge = new StandardBridge();
        bridgeProxy = new Proxy(address(standardBridge), address(0x4a421c218841eAe89Ef88Cf4f8Cd2A650123E758), "");

        wwaves = new UnitsMintableERC20(address(bridgeProxy), "WAVES", "WAVES", 8);
//        terc20 = new TERC20();

        vm.stopBroadcast();

        _writeTemp("standard_bridge", address(bridgeProxy));
        _writeTemp("wwaves", address(wwaves));
//        _writeTemp("terc20", address(terc20));
    }

    /// @notice Adds a deployment to the temp deployments file
    function _writeTemp(string memory _name, address _deployed) internal {
        vm.writeJson({json: stdJson.serialize("", _name, _deployed), path: tempDeploymentsPath});
    }
}
