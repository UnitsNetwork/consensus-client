// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {Proxy, ProxyAdmin} from "../src/Proxy.sol";
import {Script, console} from "forge-std/Script.sol";
import {StandardBridge} from "../src/StandardBridge.sol";
import {WWaves} from "../src/WWaves.sol";
import { stdJson } from "forge-std/StdJson.sol";

contract Deployer is Script {
    StandardBridge public standardBridge;
    Proxy public bridgeProxy;
    Proxy public wavesProxy;
    ProxyAdmin public bridgeProxyAdmin;
    ProxyAdmin public wavesProxyAdmin;
//    TERC20 public terc20;
    WWaves public wwaves;

    /// @notice The namespace for the deployment. Can be set with the env var DEPLOYMENT_CONTEXT.
    string internal deploymentContext;
    /// @notice Path to the deploy artifact generated by foundry
    string internal deployPath;
    /// @notice Path to the directory containing the hh deploy style artifacts
    string internal deploymentsDir;
    /// @notice The name of the deploy script that sends the transactions.
    ///         Can be modified with the env var DEPLOY_SCRIPT
    string internal deployScript;
    /// @notice The path to the temp deployments file
    string internal tempDeploymentsPath;
    /// @notice Error for when attempting to fetch a deployment and it does not exist

    function setUp() public {
        string memory root = vm.projectRoot();
        deployScript = vm.envOr("DEPLOY_SCRIPT", string("default"));

        string memory sig = vm.envOr("SIG", string("run"));
        string memory deployFile = vm.envOr("DEPLOY_FILE", string.concat(sig, "-latest.json"));
        uint256 chainId = vm.envOr("CHAIN_ID", block.chainid);
        deployPath = string.concat(root, "/broadcast/", deployScript, ".s.sol/", vm.toString(chainId), "/", deployFile);

        deploymentsDir = string.concat(root, "/target/deployments/", vm.toString(chainId));
        try vm.createDir(deploymentsDir, true) { } catch (bytes memory) { }

        string memory chainIdPath = string.concat(deploymentsDir, "/.chainId");
        try vm.readFile(chainIdPath) returns (string memory localChainId) {
            if (vm.envOr("STRICT_DEPLOYMENT", true)) {
                require(
                    vm.parseUint(localChainId) == chainId,
                    string.concat("Misconfigured networks: ", localChainId, " != ", vm.toString(chainId))
                );
            }
        } catch {
            vm.writeFile(chainIdPath, vm.toString(chainId));
        }
        console.log("Connected to network with chainid %s", chainId);

        tempDeploymentsPath = string.concat(deploymentsDir, "/.deploy");
        try vm.readFile(tempDeploymentsPath) returns (string memory) { }
        catch {
            vm.writeJson("{}", tempDeploymentsPath);
        }
        console.log("Storing temp deployment data in %s", tempDeploymentsPath);
    }

    function run() public {
        vm.startBroadcast();

        standardBridge = new StandardBridge();
        bridgeProxyAdmin = new ProxyAdmin(0x4a421c218841eAe89Ef88Cf4f8Cd2A650123E758);
        bridgeProxy = new Proxy(address(standardBridge), address(bridgeProxyAdmin), "");

        wavesProxyAdmin = new ProxyAdmin(0x4a421c218841eAe89Ef88Cf4f8Cd2A650123E758);
        wwaves = new WWaves(address(bridgeProxy));
        wavesProxy = new Proxy(address(wwaves), address(wavesProxyAdmin), "");

//        terc20 = new TERC20();

        vm.stopBroadcast();

        _writeTemp("standard_bridge", address(bridgeProxy));
        _writeTemp("wwaves", address(wwaves));
        _writeTemp("terc20", address(terc20));
    }

    /// @notice Adds a deployment to the temp deployments file
    function _writeTemp(string memory _name, address _deployed) internal {
        vm.writeJson({ json: stdJson.serialize("", _name, _deployed), path: tempDeploymentsPath });
    }
}
